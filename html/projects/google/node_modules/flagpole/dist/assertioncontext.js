"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const assertion_1 = require("./assertion");
const assertionresult_1 = require("./logging/assertionresult");
const util_1 = require("./util");
const flagpoleexecutionoptions_1 = require("./flagpoleexecutionoptions");
class AssertionContext {
    constructor(scenario, response) {
        this._assertions = [];
        this._subScenarios = [];
        this._scenario = scenario;
        this._response = response;
    }
    get response() {
        return this._response;
    }
    get scenario() {
        return this._scenario;
    }
    get suite() {
        return this._scenario.suite;
    }
    get browserControl() {
        return this.response.isBrowser ? this._scenario.getBrowserControl() : null;
    }
    get executionOptions() {
        return flagpoleexecutionoptions_1.FlagpoleExecution.opts;
    }
    get page() {
        return this.browserControl !== null ? this.browserControl.page : null;
    }
    get incompleteAssertions() {
        const incompleteAssertions = [];
        this._assertions.forEach((assertion) => {
            if (!assertion.assertionMade) {
                incompleteAssertions.push(assertion);
            }
        });
        return incompleteAssertions;
    }
    get assertionsResolved() {
        const promises = [];
        this._assertions.forEach((assertion) => {
            if (assertion.assertionMade) {
                promises.push(assertion.result);
            }
        });
        return Promise.all(promises);
    }
    get subScenariosResolved() {
        return Promise.all(this._subScenarios);
    }
    comment(input) {
        this._scenario.comment(input);
        return this;
    }
    assert(a, b) {
        const value = typeof b !== "undefined" ? b : a;
        const message = typeof b !== "undefined" ? a : undefined;
        const assertion = new assertion_1.Assertion(this, value, message);
        this._assertions.push(assertion);
        return assertion;
    }
    pause(milliseconds) {
        return new Promise((resolve) => {
            setTimeout(() => {
                this._completedAction("PAUSE", `${milliseconds}ms`);
                resolve();
            }, milliseconds);
        });
    }
    findHavingText(selector, searchForText) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.response.findHavingText(selector, searchForText);
        });
    }
    findAllHavingText(selector, searchForText) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.response.findAllHavingText(selector, searchForText);
        });
    }
    clearThenType(selector, textToType, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.clear(selector);
            return this.type(selector, textToType, opts);
        });
    }
    clear(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.clear(selector);
            this._completedAction("CLEAR", selector);
        });
    }
    type(selector, textToType, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.type(selector, textToType, opts);
            this._completedAction("TYPE", textToType);
        });
    }
    select(selector, value) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.selectOption(selector, value);
            this._completedAction("SELECT", typeof value == "string" ? value : value.join(", "));
        });
    }
    evaluate(callback) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.response.evaluate(this, callback);
        });
    }
    waitForReady(timeout = 15000) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.waitForReady(timeout);
            this._completedAction("WAIT", "Ready");
        });
    }
    waitForLoad(timeout = 30000) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.waitForLoad(timeout);
            this._completedAction("WAIT", "Load");
        });
    }
    waitForNetworkIdle(timeout = 10000) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.waitForNetworkIdle(timeout);
            this._completedAction("WAIT", "Network Idle");
        });
    }
    waitForNavigation(timeout = 10000, waitFor) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.response.waitForNavigation(timeout, waitFor);
            this._completedAction("WAIT", "Navigation");
        });
    }
    waitForHavingText(selector, text, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.response.waitForHavingText(selector, text, timeout);
            const label = `Having Text: ${text}`;
            el.isNull()
                ? this._failedAction(label, selector)
                : this._completedAction(label, selector);
            return el;
        });
    }
    waitForXPath(xPath, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.response.waitForXPath(xPath, timeout);
            el.isNull()
                ? this._failedAction("XPATH", xPath)
                : this._completedAction("XPATH", xPath);
            return el;
        });
    }
    waitForHidden(selector, timeout = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.response.waitForHidden(selector, timeout);
            el.isNull()
                ? this._failedAction("HIDDEN", selector)
                : this._completedAction("HIDDEN", selector);
            return el;
        });
    }
    waitForVisible(selector, timeout = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.response.waitForVisible(selector, timeout);
            el.isNull()
                ? this._failedAction("VISIBLE", selector)
                : this._completedAction("VISIBLE", selector);
            return el;
        });
    }
    waitForExists(selector, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.response.waitForExists(selector, timeout);
            el.isNull()
                ? this._failedAction("EXISTS", `${selector}`)
                : this._completedAction("EXISTS", `${selector}`);
            return el;
        });
    }
    exists(a, b) {
        return __awaiter(this, void 0, void 0, function* () {
            const selector = typeof b === "string" ? b : a;
            const message = typeof b === "string" ? a : null;
            const el = yield this.response.find(selector);
            if (!!message) {
                el.isNull()
                    ? this.scenario.result(new assertionresult_1.AssertionFail(message, selector))
                    : this.scenario.result(new assertionresult_1.AssertionPass(message));
            }
            else {
                el.isNull()
                    ? this._failedAction("EXISTS", `${selector}`)
                    : this._completedAction("EXISTS", `${selector}`);
            }
            return el;
        });
    }
    find(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.response.find(selector);
        });
    }
    findAll(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.response.findAll(selector);
        });
    }
    findXPath(xPath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.response.findXPath(xPath);
        });
    }
    findAllXPath(xPath) {
        return this.response.findAllXPath(xPath);
    }
    submit(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.exists(selector);
            if (el === null) {
                throw new Error(`Element with selector ${selector} not found.`);
            }
            if ("submit" in el) {
                return el.submit();
            }
            return null;
        });
    }
    click(selector, a, b) {
        return __awaiter(this, void 0, void 0, function* () {
            const el = yield this.find(selector);
            const overloaded = util_1.getMessageAndCallbackFromOverloading(a, b, selector);
            if ("click" in el) {
                if (overloaded.scenario) {
                    return el.click(overloaded.scenario);
                }
                if (overloaded.isSubScenario) {
                    return el.click(overloaded.message, overloaded.callback);
                }
                return el.click();
            }
        });
    }
    openInBrowser() {
        return __awaiter(this, void 0, void 0, function* () {
            const output = this.response.body.toString();
            const filePath = yield util_1.openInBrowser(output);
            this.scenario.comment(`Open response in browser temp file: ${filePath}`);
            return filePath;
        });
    }
    screenshot(a, b) {
        const output = (() => {
            if (typeof a === "string") {
                return b ? this.response.screenshot(a, b) : this.response.screenshot(a);
            }
            return a ? this.response.screenshot(a) : this.response.screenshot();
        })();
        this._completedAction("SCREENSHOT");
        return output;
    }
    set(aliasName, value) {
        this._scenario.set(aliasName, value);
        return this;
    }
    get(aliasName) {
        return this._scenario.get(aliasName);
    }
    _completedAction(verb, noun) {
        return __awaiter(this, void 0, void 0, function* () {
            this.scenario.result(new assertionresult_1.AssertionActionCompleted(verb, noun || ""));
        });
    }
    _failedAction(verb, noun) {
        return __awaiter(this, void 0, void 0, function* () {
            this.scenario.result(new assertionresult_1.AssertionActionFailed(verb, noun || ""));
        });
    }
}
exports.AssertionContext = AssertionContext;
//# sourceMappingURL=assertioncontext.js.map