"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const response_1 = require("./response");
const enums_1 = require("./enums");
const cssrule_1 = require("./cssrule");
const util_1 = require("./util");
const css = require('css');
class CssResponse extends response_1.ProtoResponse {
    get responseTypeName() {
        return 'Stylesheet';
    }
    get responseType() {
        return enums_1.ResponseType.stylesheet;
    }
    init(httpResponse) {
        super.init(httpResponse);
        this.context.assert(this.statusCode).between(200, 299);
        this.context.assert(this.header('Content-Type')).contains('text/css');
        try {
            this.css = css.parse(this.body.$, { silent: true });
        }
        catch (ex) {
            this.css = null;
        }
        this.validate();
    }
    evaluate(context, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error('Evaluate does not support stylesheets.');
        });
    }
    find(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.css.stylesheet && util_1.toType(this.css.stylesheet.rules) == 'array') {
                const rules = this.css.stylesheet.rules;
                let matchingRule = null;
                rules.some((rule) => {
                    if (rule.type == 'rule' && rule.selectors) {
                        rule.selectors.some((selector) => {
                            if (selector == path) {
                                matchingRule = rule;
                            }
                            return (matchingRule !== null);
                        });
                    }
                    return (matchingRule !== null);
                });
                return cssrule_1.CSSRule.create(matchingRule, this.context, `CSS Rule for ${path}`, path);
            }
            throw new Error('CSS is invalid');
        });
    }
    findAll(path) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.css.stylesheet && util_1.toType(this.css.stylesheet.rules) == 'array') {
                const rules = this.css.stylesheet.rules;
                let matchingRules = [];
                rules.forEach((rule) => {
                    if (rule.type == 'rule' && rule.selectors) {
                        rule.selectors.forEach((selector) => {
                            if (selector == path) {
                                const cssRule = cssrule_1.CSSRule.create(rule, this.context, `CSS Rule for ${path}`, path);
                                matchingRules.push(cssRule);
                            }
                        });
                    }
                });
                return matchingRules;
            }
            throw new Error('CSS is invalid');
        });
    }
    validate() {
        this.context.assert('CSS is valid', (this.css &&
            this.css.type == 'stylesheet' &&
            this.css.stylesheet &&
            this.css.stylesheet.parsingErrors &&
            this.css.stylesheet.parsingErrors.length === 0)).equals(true);
    }
}
exports.CssResponse = CssResponse;
//# sourceMappingURL=cssresponse.js.map