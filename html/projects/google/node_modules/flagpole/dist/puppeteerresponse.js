"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const domresponse_1 = require("./domresponse");
const puppeteerelement_1 = require("./puppeteerelement");
const util_1 = require("./util");
class PuppeteerResponse extends domresponse_1.DOMResponse {
    get isBrowser() {
        return true;
    }
    get browserControl() {
        return this.scenario.getBrowserControl();
    }
    get page() {
        return this.scenario.getBrowserControl().page;
    }
    get browser() {
        return this.scenario.getBrowserControl().browser;
    }
    get response() {
        return this.scenario.getBrowserControl().response;
    }
    evaluate(context, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const functionName = `flagpole_${Date.now()}`;
                const jsToInject = `window.${functionName} = ${callback}`;
                yield this.page.addScriptTag({ content: jsToInject });
                return yield this.page.evaluate((functionName) => {
                    return window[functionName]();
                }, functionName);
            }
            throw new Error("Cannot evaluate code becuase page is null.");
        });
    }
    waitForNetworkIdle(timeout = 10000) {
        const _super = Object.create(null, {
            waitForNetworkIdle: { get: () => super.waitForNetworkIdle }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                yield this.page.waitForNavigation({
                    timeout: timeout,
                    waitUntil: "networkidle0",
                });
                return;
            }
            return _super.waitForNetworkIdle.call(this, timeout);
        });
    }
    waitForNavigation(timeout = 10000, waitFor) {
        const _super = Object.create(null, {
            waitForNavigation: { get: () => super.waitForNavigation }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const allowedOptions = [
                    "load",
                    "domcontentloaded",
                    "networkidle0",
                    "networkidle2",
                ];
                const waitForEvent = (() => {
                    if (typeof waitFor == "string" &&
                        allowedOptions.indexOf(waitFor) >= 0) {
                        return [waitFor];
                    }
                    else if (util_1.toType(waitFor) == "array" &&
                        waitFor.every((waitForItem) => {
                            return allowedOptions.indexOf(waitForItem) >= 0;
                        })) {
                        return waitFor;
                    }
                    else {
                        return ["networkidle2"];
                    }
                })();
                yield this.page.waitForNavigation({
                    timeout: timeout,
                    waitUntil: waitForEvent,
                });
                return;
            }
            return _super.waitForNavigation.call(this, timeout, waitFor);
        });
    }
    waitForLoad(timeout = 30000) {
        const _super = Object.create(null, {
            waitForLoad: { get: () => super.waitForLoad }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                yield this.page.waitForNavigation({
                    timeout: timeout,
                    waitUntil: "load",
                });
                return;
            }
            return _super.waitForLoad.call(this, timeout);
        });
    }
    waitForReady(timeout = 15000) {
        const _super = Object.create(null, {
            waitForReady: { get: () => super.waitForReady }
        });
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                yield this.page.waitForNavigation({
                    timeout: timeout,
                    waitUntil: "domcontentloaded",
                });
                return;
            }
            return _super.waitForReady.call(this, timeout);
        });
    }
    waitForHidden(selector, timeout = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const opts = { timeout: timeout || 100, hidden: true };
                const element = yield this.page.waitForSelector(selector, opts);
                return puppeteerelement_1.PuppeteerElement.create(element, this.context, selector, selector);
            }
            throw new Error("waitForHidden is not available in this context");
        });
    }
    waitForVisible(selector, timeout = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const opts = { timeout: timeout || 100, visible: true };
                const element = yield this.page.waitForSelector(selector, opts);
                return puppeteerelement_1.PuppeteerElement.create(element, this.context, selector, selector);
            }
            throw new Error("waitForVisible is not available in this context");
        });
    }
    waitForExists(selector, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const opts = { timeout: timeout || 100 };
                const element = yield this.page.waitForSelector(selector, opts);
                return puppeteerelement_1.PuppeteerElement.create(element, this.context, selector, selector);
            }
            throw new Error("waitForExists is not available in this context");
        });
    }
    waitForXPath(xPath, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const opts = { timeout: timeout || 100 };
                const element = yield this.page.waitForXPath(xPath, opts);
                return puppeteerelement_1.PuppeteerElement.create(element, this.context, xPath, xPath);
            }
            throw new Error("waitForXPath is not available in this context");
        });
    }
    waitForHavingText(selector, text, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const opts = { timeout: timeout || 100 };
                const element = yield this.page.waitForFunction(`document.querySelector("${selector}").innerText.includes("${text}")`, opts);
                return puppeteerelement_1.PuppeteerElement.create(element, this.context, selector, selector);
            }
            throw new Error("waitForExists is not available in this context");
        });
    }
    screenshot(a, b) {
        const localFilePath = typeof a == "string" ? a : undefined;
        const opts = (typeof a !== "string" ? a : b) || {};
        if (this.page !== null) {
            return this.page.screenshot({
                path: localFilePath || opts.path,
                encoding: "binary",
                omitBackground: opts.omitBackground || false,
                clip: opts.clip || undefined,
                fullPage: opts.fullPage || false,
            });
        }
        throw new Error(`No page found, so can't take a screenshot.`);
    }
    type(selector, textToType, opts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                return yield this.page.type(selector, textToType, opts);
            }
            throw new Error(`Can not type into element ${selector}`);
        });
    }
    clear(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page !== null) {
                const input = yield this.page.$(selector);
                if (input !== null) {
                    yield input.click({ clickCount: 3 });
                    return yield this.page.keyboard.press("Backspace");
                }
            }
            throw new Error(`Can not type into this element ${selector}`);
        });
    }
    selectOption(selector, value) {
        if (this.page !== null) {
            const values = typeof value == "string" ? [value] : value;
            return this.page.select.apply(this.page, [selector].concat(values));
        }
        throw new Error("Page was null.");
    }
}
exports.PuppeteerResponse = PuppeteerResponse;
//# sourceMappingURL=puppeteerresponse.js.map