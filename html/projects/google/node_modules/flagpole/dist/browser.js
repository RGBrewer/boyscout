"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const puppeteer = require("puppeteer-core");
class Browser {
    constructor() {
        this.opts = {};
        this.page = null;
        this.consoleMessages = [];
        this.puppeteer = null;
    }
    get dynamicPuppeteer() {
        if (!this.puppeteer) {
            return Promise.resolve().then(() => require('puppeteer')).then(newPuppeteer => {
                this.puppeteer = newPuppeteer;
                return this.puppeteer;
            })
                .catch((e) => {
                this.puppeteer = puppeteer;
                return this.puppeteer;
            });
        }
        return Promise.resolve(this.puppeteer);
    }
    open(opts) {
        const browser = this;
        browser.opts = opts;
        return this.dynamicPuppeteer
            .then((puppeteer) => {
            const launchOptions = {
                ignoreHTTPSErrors: true,
                headless: browser.opts.headless,
                defaultViewport: {
                    width: browser.opts.width || 800,
                    height: browser.opts.height || 600,
                },
            };
            if (browser.opts.puppeteerLaunchOptions) {
                Object.assign(launchOptions, browser.opts.puppeteerLaunchOptions);
            }
            return puppeteer.launch(launchOptions)
                .then(this.onBrowserReady)
                .then((page) => {
                return this.onPageReady(browser, page);
            })
                .then((response) => {
                return this.onResponse(browser, response);
            });
        });
    }
    select(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.page === null) {
                throw 'Page not loaded';
            }
            return yield this.page.$$(selector);
        });
    }
    onBrowserReady(browser) {
        return browser.pages()
            .then((pages) => {
            return (pages.length > 0) ?
                pages[0] : browser.newPage();
        });
    }
    onPageReady(browser, page) {
        return __awaiter(this, void 0, void 0, function* () {
            browser.page = page;
            if (typeof browser.opts.uri == 'undefined') {
                throw 'Must have a URL to load.';
            }
            if (browser.opts.recordConsole) {
                page.on('console', (consoleMesssage) => {
                    if (browser.opts.outputConsole) {
                        console.log(`Console: ${consoleMesssage.type().toUpperCase()} - ${consoleMesssage.text()}`);
                    }
                    browser.consoleMessages.push({
                        type: consoleMesssage.type(),
                        text: consoleMesssage.text(),
                        source: consoleMesssage
                    });
                });
            }
            if (typeof browser.opts.jar != 'undefined') {
                let cookies = [];
                browser.opts.jar.getCookies(browser.opts.uri).forEach((cookie) => {
                    cookies.push({
                        name: cookie.key,
                        value: cookie.value,
                        domain: cookie.domain || undefined,
                        path: cookie.path || '/',
                        httpOnly: cookie.httpOnly,
                        secure: cookie.secure
                    });
                });
                page.setCookie(...cookies);
            }
            return page.goto(browser.opts.uri, { waitUntil: 'networkidle2' })
                .then((response) => {
                return response;
            });
        });
    }
    onResponse(browser, response) {
        const page = browser.page;
        if (page !== null) {
            return page.content()
                .then((body) => {
                return {
                    response: response,
                    body: body,
                };
            });
        }
        throw 'No response';
    }
    getConsoleMessages() {
        return this.consoleMessages;
    }
    has404() {
        return this.find404Errors().length > 0;
    }
    find404Errors() {
        return this.getConsoleMessages()
            .filter((consoleMessage) => {
            const text = consoleMessage.text;
            return text.indexOf('404 (Not Found)') > -1;
        });
    }
    getPage() {
        return this.page;
    }
}
exports.Browser = Browser;
;
//# sourceMappingURL=browser.js.map