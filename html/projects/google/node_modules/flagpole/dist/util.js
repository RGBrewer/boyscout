"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const cheerio = require("cheerio");
function isNullOrUndefined(obj) {
    return typeof obj === "undefined" || obj === null;
}
exports.isNullOrUndefined = isNullOrUndefined;
function isAsyncCallback(func) {
    return func.toString().indexOf("=> __awaiter(") > 0;
}
exports.isAsyncCallback = isAsyncCallback;
function toType(obj) {
    if (typeof obj === "undefined") {
        return "undefined";
    }
    else if (obj === null) {
        return "null";
    }
    else if (obj === NaN) {
        return "nan";
    }
    else if (obj instanceof cheerio) {
        return "cheerio";
    }
    else if (!!obj &&
        (typeof obj === "object" || typeof obj === "function") &&
        typeof obj.then === "function" &&
        typeof obj.catch === "function") {
        return "promise";
    }
    else if (obj && obj.constructor && obj.constructor.name) {
        return String(obj.constructor.name).toLocaleLowerCase();
    }
    else if (obj && obj.constructor && obj.constructor.toString) {
        let arr = obj.constructor.toString().match(/function\s*(\w+)/);
        if (arr && arr.length == 2) {
            return String(arr[1]).toLocaleLowerCase();
        }
    }
    const match = {}.toString
        .call(obj)
        .match(/\s([a-zA-Z]+)/);
    return match !== null ? String(match[1]).toLocaleLowerCase() : "";
}
exports.toType = toType;
function uniqueId() {
    return ("_" +
        Math.random()
            .toString(36)
            .substr(2, 9));
}
exports.uniqueId = uniqueId;
function openInBrowser(content) {
    return __awaiter(this, void 0, void 0, function* () {
        const open = require("open");
        const tmp = require("tmp");
        const tmpObj = tmp.fileSync({ postfix: ".html" });
        const filePath = tmpObj.name;
        console.log(filePath);
        fs.writeFileSync(filePath, content);
        yield open(filePath);
        return filePath;
    });
}
exports.openInBrowser = openInBrowser;
function runAsync(callback, delay = 1) {
    setTimeout(callback, delay);
}
exports.runAsync = runAsync;
function asyncForEach(array, callback) {
    return new Promise(resolve => {
        Promise.all(array.map(callback)).then(() => {
            resolve();
        });
    });
}
exports.asyncForEach = asyncForEach;
function asyncEvery(array, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(array.map(callback)).then(values => values.every(v => v));
    });
}
exports.asyncEvery = asyncEvery;
function asyncEvery2(array, callback) {
    return new Promise(resolve => {
        const promises = [];
        for (let i = 0; i < array.length; i++) {
            promises.push(callback(array[i], i, array));
        }
        Promise.all(promises).then((values) => {
            const boo = values.every(value => {
                return value;
            });
            resolve(boo);
        });
    });
}
exports.asyncEvery2 = asyncEvery2;
function asyncNone(array, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(array.map(callback)).then(values => !values.some(v => v));
    });
}
exports.asyncNone = asyncNone;
function asyncNone2(array, callback) {
    return new Promise(resolve => {
        const promises = [];
        for (let i = 0; i < array.length; i++) {
            promises.push(callback(array[i], i, array));
        }
        Promise.all(promises).then((values) => {
            const boo = !values.some(value => {
                return value;
            });
            resolve(boo);
        });
    });
}
exports.asyncNone2 = asyncNone2;
function asyncSome(array, callback) {
    return __awaiter(this, void 0, void 0, function* () {
        return Promise.all(array.map(callback)).then(values => values.some(v => v));
    });
}
exports.asyncSome = asyncSome;
function asyncSome2(array, callback) {
    return new Promise(resolve => {
        const promises = [];
        for (let i = 0; i < array.length; i++) {
            promises.push(callback(array[i], i, array));
        }
        Promise.all(promises).then((values) => {
            const boo = values.some(value => {
                return value;
            });
            resolve(boo);
        });
    });
}
exports.asyncSome2 = asyncSome2;
function normalizePath(uri) {
    if (uri) {
        uri = uri.endsWith(path.sep) ? uri : uri + path.sep;
    }
    return uri;
}
exports.normalizePath = normalizePath;
function ensureFolderExists(path) {
    if (!fs.existsSync(path)) {
        fs.mkdirSync(path, { recursive: true });
    }
}
exports.ensureFolderExists = ensureFolderExists;
function emptyFolder(folderPath) {
    return new Promise((resolve, reject) => {
        folderPath = path.resolve(folderPath);
        ensureFolderExists(folderPath);
        fs.readdir(folderPath, (err, files) => {
            if (err)
                reject(err);
            const promises = [];
            for (const file of files) {
                promises.push(fs.promises.unlink(path.join(folderPath, file)));
            }
            Promise.all(promises)
                .then(() => {
                resolve();
            })
                .catch(err => {
                reject(err);
            });
        });
    });
}
exports.emptyFolder = emptyFolder;
function exitProcess(passed) {
    process.exit(passed ? 0 : 1);
}
exports.exitProcess = exitProcess;
function getMessageAndCallbackFromOverloading(a, b, defaultMessage = "Untitled") {
    const message = typeof a == "string" ? a : defaultMessage;
    const callback = (function () {
        if (typeof b == "function") {
            return b;
        }
        else if (typeof a == "function") {
            return a;
        }
        else {
            return function () { };
        }
    })();
    const scenario = (function () {
        if (toType(a) == "scenario") {
            return a;
        }
        else if (toType(b) == "scenario") {
            return b;
        }
        return undefined;
    })();
    return {
        isSubScenario: a || b,
        message: message,
        callback: callback,
        scenario: scenario
    };
}
exports.getMessageAndCallbackFromOverloading = getMessageAndCallbackFromOverloading;
//# sourceMappingURL=util.js.map