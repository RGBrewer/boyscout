"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_1 = require("./cli");
const testrunner_1 = require("./testrunner");
const cli_ansi_1 = require("./cli-ansi");
const flagpoleexecutionoptions_1 = require("../flagpoleexecutionoptions");
const prompts = require("prompts");
const cli_helper_1 = require("./cli-helper");
const build_1 = require("./build");
const ansi = new cli_ansi_1.CliAnsi();
const suitesInProject = cli_1.Cli.config.getSuites();
const filterBySuiteName = (selectedSuites, suiteNames) => {
    if (suiteNames && suiteNames.length > 0) {
        const regExes = (() => {
            const regExes = [];
            (suiteNames || []).forEach((name) => {
                const regexString = name.replace(".", ".").replace("*", ".*");
                regExes.push(new RegExp(`^${regexString}$`, "i"));
            });
            return regExes;
        })();
        selectedSuites = selectedSuites.filter((suite) => {
            return regExes.some((regEx) => {
                return regEx.test(suite.name);
            });
        });
    }
    return selectedSuites;
};
const filterByTag = (selectedSuites, tag) => {
    if (tag && tag.length) {
        selectedSuites = selectedSuites.filter((suite) => {
            return suite.tags.includes(tag);
        });
    }
    return selectedSuites;
};
const promptForWhatToRun = () => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield prompts(cli_helper_1.promptSelect("run", "What tests do you want to run?", cli_helper_1.stringArrayToPromptChoices(["All", "Choose Suites", "By Tag", "None"]), 0));
    return response.run;
});
const promptForSuites = (selectedSuites) => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield prompts({
        type: "multiselect",
        name: "suitesNames",
        message: "Which suites do you want to run?",
        choices: cli_helper_1.stringArrayToPromptChoices(selectedSuites.map((suite) => {
            return suite.name;
        })),
    });
    return response.suitesNames || [];
});
const promptForTag = () => __awaiter(void 0, void 0, void 0, function* () {
    const response = yield prompts(cli_helper_1.promptSelect("tag", "What tag do you want to run?", cli_helper_1.stringArrayToPromptChoices(cli_1.Cli.config.getTags())));
    return response.tag;
});
exports.run = (suiteNames, tag, runAll) => __awaiter(void 0, void 0, void 0, function* () {
    if (cli_1.Cli.commandArg === "build") {
        yield build_1.build(false);
    }
    cli_helper_1.printSubheader("Run Test Suites");
    let selectedSuites = suitesInProject;
    if (!runAll) {
        if (!suiteNames.length && !tag.length) {
            const whatToRun = yield promptForWhatToRun();
            if (whatToRun === "By Tag") {
                tag = yield promptForTag();
            }
            else if (whatToRun === "Choose Suites") {
                suiteNames = yield promptForSuites(selectedSuites);
            }
            else if (whatToRun === "None") {
                selectedSuites = [];
            }
        }
        selectedSuites = filterBySuiteName(selectedSuites, suiteNames);
        selectedSuites = filterByTag(selectedSuites, tag);
    }
    if (selectedSuites.length) {
        cli_1.Cli.log("Running Suites: " +
            selectedSuites
                .map((suite) => {
                return suite.name;
            })
                .join(", "));
        return runSuites(selectedSuites);
    }
    cli_1.Cli.log("No tests selected to run.");
    cli_1.Cli.exit(0);
});
const runSuites = (selectedSuites) => __awaiter(void 0, void 0, void 0, function* () {
    const runner = new testrunner_1.TestRunner();
    selectedSuites.forEach(function (suite) {
        runner.addSuite(suite);
    });
    if (flagpoleexecutionoptions_1.FlagpoleExecution.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.console) {
        if (runner.suites.length == 0) {
            cli_1.Cli.log("Did not find any test suites to run.\n");
            cli_1.Cli.exit(2);
        }
        ansi.writeLine();
        const states = ["/", "â€”", "\\", "|"];
        let stateIndex = 0;
        let statusMessage = `Loading ${runner.suites.length} test suites...`;
        let timer = setInterval(() => {
            ansi.writeLine(ansi.cursorUp(), ansi.eraseLine(), `${states[stateIndex]} ${statusMessage}`);
            stateIndex = stateIndex < states.length - 1 ? stateIndex + 1 : 0;
        }, 100);
        runner.subscribe((message) => {
            statusMessage = message;
        });
        yield runner.runSpawn();
        clearInterval(timer);
        ansi.write(ansi.eraseLines(2));
    }
    else {
        yield runner.runSpawn();
    }
    cli_1.Cli.exit(runner.exitCode);
});
//# sourceMappingURL=run.js.map