"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const config_1 = require("./config");
const clortho_lite_1 = require("clortho-lite");
const cli_helper_1 = require("./cli-helper");
const fs = require("fs");
const path = require("path");
class Cli {
    static configFileExists() {
        return Cli.configPath && fs.existsSync(Cli.configPath);
    }
    static isInitialized() {
        return Cli.configFileExists() && Cli.config && Cli.config.isValid();
    }
    static log(message) {
        if (typeof message !== "undefined") {
            Cli.consoleLog.push(message.replace(/\n$/, ""));
        }
    }
    static list(list) {
        list.forEach(function (message) {
            Cli.log("  Â» " + message);
        });
    }
    static exit(exitCode) {
        if (!Cli.hideBanner) {
            cli_helper_1.printHeader();
        }
        Cli.consoleLog.forEach((output) => {
            const lines = output.split("\n");
            lines.forEach((line) => {
                process.send ? process.send(line) : console.log(line);
            });
        });
        process.exit(exitCode);
    }
    static getCredentials() {
        const serviceName = "Flagpole JS";
        const service = new clortho_lite_1.ClorthoService(serviceName);
        let token;
        let email;
        return new Promise((resolve, reject) => {
            Promise.all([
                new Promise((resolve, reject) => {
                    service
                        .get("token")
                        .then(function (credentials) {
                        token = credentials.password;
                        resolve();
                    })
                        .catch(function () {
                        reject("No saved token.");
                    });
                }),
                new Promise((resolve, reject) => {
                    service
                        .get("email")
                        .then(function (credentials) {
                        email = credentials.password;
                        resolve();
                    })
                        .catch(function () {
                        reject("No saved email.");
                    });
                }),
            ])
                .then(function () {
                resolve({
                    email: email,
                    token: token,
                });
            })
                .catch(function (err) {
                reject("Not logged in. " + err);
            });
        });
    }
    static findJsFilesInTestFolder() {
        let startFolder = Cli.config.getTestsFolder();
        let suitesInFolder = [];
        function findSuites(dir, isSubFolder = false) {
            if (fs.existsSync(dir)) {
                let files = fs.readdirSync(dir);
                files.forEach(function (file) {
                    if (!isSubFolder && fs.statSync(dir + file).isDirectory()) {
                        findSuites(dir + file + "/", true);
                    }
                    else if (file.match(/.js$/)) {
                        let name = (dir + file)
                            .replace(startFolder, "")
                            .replace(/\.js$/i, "");
                        suitesInFolder.push(name);
                    }
                });
            }
        }
        findSuites(startFolder);
        return suitesInFolder;
    }
    static findDetachedSuites() {
        const suitesInFolder = Cli.findJsFilesInTestFolder();
        let suitesAvailableToImport = [];
        let suitesInConfig = Cli.config.getSuiteNames();
        suitesInFolder.forEach(function (suiteName) {
            if (!suitesInConfig.includes(suiteName)) {
                suitesAvailableToImport.push(suiteName);
            }
        });
        return suitesAvailableToImport;
    }
    static addScenario(suite, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const suitePath = suite.getSourcePath();
                const fileContents = "\n\n" +
                    `suite.${opts.type}("${opts.description}")` +
                    "\n" +
                    `   .open("${opts.path}")` +
                    "\n" +
                    `   .next(async (context) => {` +
                    "\n" +
                    `       ` +
                    "\n" +
                    `   });` +
                    "\n";
                if (!fs.existsSync(suitePath)) {
                    reject(`Suite file ${suitePath} does not exist.`);
                }
                fs.appendFile(suitePath, fileContents, function (err) {
                    if (err) {
                        reject(err);
                    }
                    resolve();
                });
            });
        });
    }
    static addSuite(suite, scenario) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve, reject) => {
                const suiteConfig = new config_1.SuiteConfig(Cli.config, suite);
                const suitePath = suiteConfig.getSourcePath();
                let fileContents = Cli.config.project.isSourceAndOutput
                    ? `import { Flagpole } from "flagpole";`
                    : `const { Flagpole } = require("flagpole");`;
                fileContents +=
                    "\n\n" +
                        `const suite = Flagpole.suite('${suite.description || ""}');` +
                        "\n\n" +
                        `suite.${scenario.type}("${scenario.description}")` +
                        "\n" +
                        `   .open("${scenario.path}")` +
                        "\n" +
                        `   .next(async (context) => {` +
                        "\n" +
                        `       ` +
                        "\n" +
                        `   });` +
                        "\n\n";
                fs.writeFile(suitePath, fileContents, function (err) {
                    if (err) {
                        return reject(err);
                    }
                    Cli.config.addSuite(suite);
                    Cli.config
                        .save()
                        .then(() => {
                        resolve(suite);
                    })
                        .catch(reject);
                });
            });
        });
    }
    static init(opts) {
        return __awaiter(this, void 0, void 0, function* () {
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                const configFile = new config_1.FlagpoleConfig(opts);
                let tasks = [];
                opts.environments.forEach((envName) => {
                    configFile.addEnvironment(envName);
                });
                const rootFolder = configFile.getRootFolder();
                if (!fs.existsSync(rootFolder)) {
                    fs.mkdirSync(rootFolder);
                    tasks.push(configFile.project.isSourceAndOutput
                        ? `Created root folder: ${rootFolder}`
                        : `Created tests folder: ${rootFolder}`);
                }
                else {
                    tasks.push(configFile.project.isSourceAndOutput
                        ? `Root folder already existed: ${rootFolder}`
                        : `Tests folder already existed: ${rootFolder}`);
                }
                yield configFile.save();
                tasks.push("Saved config file.");
                if (configFile.project.isSourceAndOutput) {
                    yield configFile.writeTsConfig();
                    tasks.push("Created tsconfig.json file.");
                    const sourceFolder = configFile.getSourceFolder();
                    if (!fs.existsSync(sourceFolder)) {
                        fs.mkdirSync(sourceFolder);
                        tasks.push("Created source folder: " + sourceFolder);
                    }
                    const outputFolder = configFile.getTestsFolder();
                    if (!fs.existsSync(outputFolder)) {
                        fs.mkdirSync(outputFolder);
                        tasks.push("Created output folder: " + outputFolder);
                    }
                }
                parseConfigFile(configFile.getConfigPath());
                resolve(tasks);
            }));
        });
    }
}
exports.Cli = Cli;
Cli.consoleLog = [];
Cli.hideBanner = false;
Cli.projectPath = process.cwd();
Cli.configPath = path.join(__dirname, "flagpole.json");
Cli.command = null;
Cli.commandArg = null;
Cli.commandArg2 = null;
Cli.apiDomain = "https://us-central1-flagpolejs-5ea61.cloudfunctions.net";
function refreshConfig() {
    const defaultConfig = {
        project: {
            name: path.basename(process.cwd()),
            path: "tests",
        },
        environments: [],
        suites: [],
    };
    if (Cli.configFileExists()) {
        const configContent = fs.readFileSync(Cli.configPath);
        let configData = null;
        try {
            configData = JSON.parse(configContent);
        }
        catch (_a) {
            configData = {};
        }
        const opts = {
            project: Object.assign(defaultConfig.project, configData.project || {}),
            environments: Object.values(Object.assign(defaultConfig.environments, configData.environments || {})),
            suites: Object.values(Object.assign(defaultConfig.suites, configData.suites || {})),
        };
        Cli.config = new config_1.FlagpoleConfig(opts);
    }
    else {
        Cli.config = new config_1.FlagpoleConfig(defaultConfig);
    }
    Cli.config.onSave(refreshConfig);
    return Cli.config;
}
exports.refreshConfig = refreshConfig;
function parseConfigFile(configPath) {
    Cli.configPath = configPath;
    return refreshConfig();
}
exports.parseConfigFile = parseConfigFile;
//# sourceMappingURL=cli.js.map