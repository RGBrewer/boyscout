"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("../util");
const child_process_1 = require("child_process");
const fs = require("fs");
const path = require("path");
class EnvConfig {
    constructor(config, opts) {
        this.config = config;
        this.name = opts.name;
        this.defaultDomain = opts.defaultDomain || "";
    }
    toJson() {
        return {
            name: this.name,
            defaultDomain: this.defaultDomain,
        };
    }
}
exports.EnvConfig = EnvConfig;
class SuiteConfig {
    constructor(config, opts) {
        this.tags = [];
        this.config = config;
        this.name = opts.name || "";
        this.id = opts.id || "";
        if (opts.tags) {
            opts.tags.forEach((tag) => {
                this.tags.push(String(tag));
            });
        }
    }
    getSourcePath() {
        return this.config.project.isSourceAndOutput
            ? path.join(this.config.getSourceFolder(), `${this.name}.ts`)
            : this.getTestPath();
    }
    getTestPath() {
        return path.join(this.config.getTestsFolder(), `${this.name}.js`);
    }
    clearTags() {
        this.tags = [];
    }
    addTag(tag) {
        tag = String(tag).trim();
        if (tag.length && this.tags.indexOf(tag) < 0) {
            this.tags.push(tag);
        }
    }
    toJson() {
        return {
            id: this.id,
            name: this.name,
            tags: [...new Set(this.tags)].filter((value) => {
                return value.trim().length > 0;
            }),
        };
    }
}
exports.SuiteConfig = SuiteConfig;
class ProjectConfig {
    constructor(config, opts) {
        this.id = "";
        this.config = config;
        this.id = opts.id || "";
        this.name = opts.name || "default";
        this.path = opts.path || "tests";
        this.images = opts.images || "images";
        this.cache = opts.cache || "cache";
        this.source = opts.source;
        this.output = opts.output;
    }
    get isSourceAndOutput() {
        return this.source !== undefined && this.output !== undefined;
    }
    get hasId() {
        return this.id.length > 0;
    }
    setTypeScriptFolders(rootFolder, srcFolder, outFolder) {
        this.path = rootFolder;
        this.source = srcFolder;
        this.output = outFolder;
        return this;
    }
    toJson() {
        return {
            id: this.id,
            name: this.name,
            path: this.path,
            source: this.source,
            output: this.output,
            images: this.images,
            cache: this.cache,
        };
    }
}
exports.ProjectConfig = ProjectConfig;
class FlagpoleConfig {
    constructor(opts) {
        this._onSave = [];
        this.suites = {};
        this.environments = {};
        this.configPath =
            opts.configPath || path.join(process.cwd(), "flagpole.json");
        this.project = new ProjectConfig(this, opts.project);
        if (opts.suites !== undefined) {
            opts.suites.forEach((suiteOpts) => {
                this.suites[suiteOpts.name] = new SuiteConfig(this, suiteOpts);
            });
        }
        opts.environments.forEach((envOpts) => {
            this.environments[envOpts.name] = new EnvConfig(this, envOpts);
        });
    }
    getConfigFolder() {
        return path.dirname(this.configPath);
    }
    getConfigPath() {
        return this.configPath;
    }
    getRootFolder() {
        return util_1.normalizePath(path.join(this.getConfigFolder(), this.project.path));
    }
    getTestsFolder() {
        return util_1.normalizePath(path.join(this.getRootFolder(), this.project.output || ""));
    }
    getSourceFolder() {
        return util_1.normalizePath(path.join(this.getRootFolder(), this.project.source || ""));
    }
    getImagesFolder() {
        return util_1.normalizePath(path.join(this.getRootFolder(), this.project.images || "images"));
    }
    getCacheFolder() {
        return util_1.normalizePath(path.join(this.getRootFolder(), this.project.cache || "cache"));
    }
    addEnvironment(opts) {
        if (opts.name.length) {
            this.environments[opts.name] = new EnvConfig(this, opts);
        }
    }
    addSuite(opts) {
        if (opts.name.length) {
            this.suites[opts.name] = new SuiteConfig(this, opts);
        }
    }
    removeEnvironment(name) {
        delete this.environments[name];
    }
    removeSuite(name) {
        delete this.suites[name];
    }
    getEnvironments() {
        let envConfigs = [];
        for (let key in this.environments) {
            envConfigs.push(this.environments[key]);
        }
        return envConfigs;
    }
    getEnvironmentNames() {
        let envs = [];
        for (let key in this.environments) {
            envs.push(this.environments[key].name);
        }
        return envs;
    }
    getTags() {
        let tags = [];
        for (let key in this.suites) {
            tags = tags.concat(this.suites[key].tags);
        }
        tags = tags.filter((tag, i) => {
            return tags.indexOf(tag) === i;
        });
        return tags.sort();
    }
    getSuites() {
        let suiteConfigs = [];
        for (let key in this.suites) {
            suiteConfigs.push(this.suites[key]);
        }
        return suiteConfigs;
    }
    getSuiteNames() {
        let suiteNames = [];
        for (let key in this.suites) {
            suiteNames.push(this.suites[key].name);
        }
        return suiteNames;
    }
    isValid() {
        if (this.project === null ||
            this.project.name.length == 0 ||
            this.project.path.length == 0) {
            return false;
        }
        if (typeof this.getTestsFolder() == "undefined" ||
            !fs.existsSync(this.getTestsFolder())) {
            return false;
        }
        if (Object.keys(this.environments).length == 0) {
            return false;
        }
        return true;
    }
    toFileObject() {
        return {
            project: this.project.toJson(),
            environments: (() => {
                let envs = {};
                Object.values(this.environments).forEach((env) => {
                    envs[env.name] = env.toJson();
                });
                return envs;
            })(),
            suites: (() => {
                let suites = {};
                Object.values(this.suites).forEach((suite) => {
                    suites[suite.name] = suite.toJson();
                });
                return suites;
            })(),
        };
    }
    toString() {
        return JSON.stringify(this.toFileObject(), null, 2);
    }
    onSave(callback) {
        this._onSave.push(callback);
    }
    save() {
        return new Promise((resolve, reject) => {
            fs.writeFile(this.getConfigPath(), this.toString(), (err) => {
                if (err) {
                    return reject(err);
                }
                this._onSave.forEach((callback) => {
                    callback();
                });
                resolve();
            });
        });
    }
    writeTsConfig() {
        return new Promise((resolve, reject) => {
            if (!this.project.isSourceAndOutput) {
                reject("Project config does not have a source and output folder defined.");
                return;
            }
            const tsconfig = {
                compilerOptions: {
                    module: "commonjs",
                    target: "es2016",
                    noImplicitAny: false,
                    sourceMap: false,
                    declaration: false,
                    rootDir: `.${path.sep}${this.project.source}`,
                    outDir: `.${path.sep}${this.project.output}`,
                    strict: true,
                    moduleResolution: "node",
                    removeComments: true,
                    preserveConstEnums: true,
                },
                include: [`src${path.sep}**${path.sep}*`],
                exclude: ["node_modules", `**${path.sep}*.spec.ts`],
            };
            const tsconfigPath = path.join(this.getRootFolder(), "tsconfig.json");
            fs.writeFile(tsconfigPath, JSON.stringify(tsconfig, null, 2), (err) => {
                if (err) {
                    return reject(err);
                }
                resolve(tsconfigPath);
            });
        });
    }
    tsc() {
        return new Promise((resolve, reject) => {
            const rootFolder = this.getRootFolder();
            const cwd = process.cwd();
            const command = `cd ${rootFolder} && tsc && cd ${cwd}`;
            child_process_1.exec(command, (err, stdout, stderr) => {
                if (err) {
                    reject(stdout || stderr || err);
                    return;
                }
                resolve(stdout);
            });
        });
    }
}
exports.FlagpoleConfig = FlagpoleConfig;
//# sourceMappingURL=config.js.map