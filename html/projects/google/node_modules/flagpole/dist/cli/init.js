"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const cli_helper_1 = require("./cli-helper");
const cli_1 = require("./cli");
const prompts = require("prompts");
function init() {
    return __awaiter(this, void 0, void 0, function* () {
        cli_helper_1.printHeader();
        cli_helper_1.printSubheader("Initialize Flagpole Project");
        const initialResponses = yield prompts([
            {
                type: "text",
                name: "project",
                message: "What is the name of your project?",
                initial: process
                    .cwd()
                    .split("/")
                    .pop(),
                format: cli_helper_1.trimInput
            },
            {
                type: "multiselect",
                name: "env",
                message: "What environments do you want to support?",
                hint: "You can easily add more later",
                initial: "dev",
                min: 1,
                max: 8,
                choices: [
                    { value: "dev", title: "dev" },
                    { value: "stag", title: "stag" },
                    { value: "prod", title: "prod" },
                    { value: "preprod", title: "preprod" },
                    { value: "qa", title: "qa" },
                    { value: "local", title: "local" },
                    { value: "alpha", title: "alpha" },
                    { value: "beta", title: "beta" }
                ],
                validate: function (input) {
                    return input.length > 0;
                }
            }
        ]);
        const domainPrompts = [];
        initialResponses.env.forEach((env) => {
            domainPrompts.push({
                type: "text",
                name: `domain_${env}`,
                message: `Default Domain for ${env}`,
                format: cli_helper_1.trimInput,
                validate: domain => {
                    return /^https?:\/\/[a-z][a-z0-9_.-]+[a-z](:[0-9]+)?(\/.*)?$/i.test(domain) ?
                        true : 'Must be a valid URL, starting with http:// or https://';
                }
            });
        });
        const domains = yield prompts(domainPrompts);
        const tsResponse = yield prompts({
            type: "toggle",
            name: "useTypeScript",
            message: "Do you want Flagpole to use TypeScript?",
            initial: true,
            active: "Yes",
            inactive: "No"
        });
        const rootFolder = yield prompts({
            type: "text",
            name: "path",
            message: tsResponse.useTypeScript
                ? "What is the root subfolder you want to put your tests in? (tsconfig.json will go here)"
                : "What subfolder do you want to put your tests in?",
            initial: "tests",
            format: cli_helper_1.trimInput
        });
        let tsFolders = undefined;
        if (tsResponse.useTypeScript) {
            tsFolders = yield prompts([
                {
                    type: "text",
                    name: "sourceFolder",
                    message: `Source Folder ${rootFolder.path}/`,
                    initial: `src`
                },
                {
                    type: "text",
                    name: "outputFolder",
                    message: `Output Folder ${rootFolder.path}/`,
                    initial: `out`
                }
            ]);
        }
        const configOptions = {
            configPath: `${process.cwd()}/flagpole.json`,
            project: {
                name: initialResponses.project,
                path: rootFolder.path,
                source: tsFolders == undefined ? undefined : tsFolders.sourceFolder,
                output: tsFolders == undefined ? undefined : tsFolders.outputFolder
            },
            environments: (() => {
                const out = [];
                initialResponses.env.forEach((env) => {
                    out.push({
                        name: env,
                        defaultDomain: domains[`domain_${env}`]
                    });
                });
                return out;
            })(),
            suites: []
        };
        cli_1.Cli.hideBanner = true;
        cli_1.Cli.log("Creating your Flagpole project...");
        cli_1.Cli.init(configOptions)
            .then((tasks) => {
            cli_1.Cli.log("");
            cli_1.Cli.list(tasks);
            cli_1.Cli.log("");
            cli_1.Cli.log("Your Flagpole project was created.");
            cli_1.Cli.exit(0);
        })
            .catch((err) => {
            cli_1.Cli.log(err);
            cli_1.Cli.exit(1);
        });
    });
}
exports.init = init;
//# sourceMappingURL=init.js.map