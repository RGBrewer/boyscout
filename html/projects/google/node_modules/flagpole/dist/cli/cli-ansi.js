"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ESC = '\x1b[';
const CURSOR_UP = 'A';
const CURSOR_DOWN = 'B';
const CURSOR_RIGHT = 'C';
const CURSOR_LEFT = 'D';
const NEXT_LINE = 'E';
const PREV_LINE = 'F';
const CURSOR_MOVE_TO_X = 'G';
const CURSOR_MOVE_TO = 'H';
const CURSOR_REPORT_POS = 'R';
const SCROLL_UP = 'S';
const SCROLL_DOWN = 'T';
const CURSOR_SAVE_POS = 's';
const CURSOR_RESTORE_POS = 'u';
const CURSOR_QUERY_POS = '6n';
const CURSOR_HIDE = '?25l';
const CURSOR_SHOW = '?25h';
const ERASE_DOWN = 'J';
const ERASE_UP = '1J';
const ERASE_SCREEN = '2J';
const ERASE_END_LINE = 'K';
const ERASE_START_LINE = '1K';
const ERASE_LINE = '2K';
const FG_BLACK = '30m';
const FG_RED = '31m';
const FG_GREEN = '32m';
const FG_YELLOW = '33m';
const FG_BLUE = '34m';
const FG_MAGENTA = '35m';
const FG_CYAN = '36m';
const FG_WHITE = '37m';
const FG_RGB = '38;2;';
const FG_CUSTOM = '38;5;';
const FG_DEFAULT = '39m';
const BG_BLACK = '40m';
const BG_RED = '41m';
const BG_GREEN = '42m';
const BG_YELLOW = '43m';
const BG_BLUE = '44m';
const BG_MAGENTA = '45m';
const BG_CYAN = '46m';
const BG_WHITE = '47m';
const BG_RGB = '48;2;';
const BG_CUSTOM = '48;5;';
const BG_DEFAULT = '49m';
const FONT_BOLD = '1m';
const FONT_LIGHT = '2m';
const FONT_ITALIC = '3m';
const FONT_UNDERLINED = '4m';
const FONT_BLINK = '5m';
const FONT_FAST_BLINK = '6m';
const FONT_INVERSE = '7m';
const FONT_HIDDEN = '8m';
const FONT_STRIKETHROUGH = '9m';
const FONT_BORDER = '51m';
const FONT_ROUNDED_BORDER = '52m';
const FONT_OVERLINE = '53m';
const FONT_RESET = '0m';
const FONT_END_BOLD = '21m';
const FONT_END_LIGHT = '22m';
const FONT_END_ITALIC = '23m';
const FONT_END_UNDERLINED = '24m';
const FONT_END_BLINK = '25m';
const FONT_END_FAST_BLINK = '26m';
const FONT_END_INVERSE = '27m';
const FONT_END_HIDDEN = '28m';
const FONT_END_STRIKETHROUGH = '29m';
const FONT_END_BORDER = '54m';
const FONT_END_OVERLINE = '54m';
class CliAnsi {
    write(...args) {
        args.forEach((arg) => {
            process.stdout.write(arg);
        });
    }
    writeLine(...args) {
        this.write.apply(this, args.concat(["\n"]));
    }
    writeLines(...args) {
        args.forEach((arg) => {
            this.writeLine(arg);
        });
    }
    cursorTo(x, y) {
        if (typeof x !== 'number') {
            throw new TypeError('The `x` argument is required');
        }
        if (typeof y !== 'number') {
            return `${ESC}${x + 1}${CURSOR_MOVE_TO_X}`;
        }
        return `${ESC}${y + 1};${x + 1}${CURSOR_MOVE_TO}`;
    }
    ;
    cursorMove(x, y) {
        return this.cursorMoveX(x) + this.cursorMoveY(y);
    }
    cursorMoveX(x) {
        if (x < 0) {
            return `${ESC}${x * -1}${CURSOR_LEFT}`;
        }
        else if (x > 0) {
            return `${ESC}${x}${CURSOR_RIGHT}`;
        }
        return '';
    }
    cursorMoveY(y) {
        if (y < 0) {
            return `${ESC}${y * -1}${CURSOR_UP}`;
        }
        else if (y > 0) {
            return `${ESC}${y}${CURSOR_DOWN}`;
        }
        return '';
    }
    cursorUp(n = 1) {
        return `${ESC}${n}${CURSOR_UP}`;
    }
    cursorDown(n = 1) {
        return `${ESC}${n}${CURSOR_DOWN}`;
    }
    cursorLeft(n = 1) {
        return `${ESC}${n}${CURSOR_LEFT}`;
    }
    cursorRight(n = 1) {
        return `${ESC}${n}${CURSOR_RIGHT}`;
    }
    cursorHome() {
        return `${ESC}${CURSOR_LEFT}`;
    }
    cursorPreviousLine() {
        return `${ESC}${PREV_LINE}`;
    }
    cursorNextLine() {
        return `${ESC}${NEXT_LINE}`;
    }
    cursorHide() {
        return `${ESC}${CURSOR_HIDE}`;
    }
    cursorShow() {
        return `${ESC}${CURSOR_SHOW}`;
    }
    cursorSavePosition() {
        return `${ESC}${CURSOR_SAVE_POS}`;
    }
    cursorRestorePosition() {
        return `${ESC}${CURSOR_RESTORE_POS}`;
    }
    cursorQueryPosition() {
        return `${ESC}${CURSOR_QUERY_POS}`;
    }
    eraseLine() {
        return `${ESC}${ERASE_LINE}`;
    }
    eraseLines(numLines) {
        let clear = '';
        for (let i = 0; i < numLines; i++) {
            clear += this.eraseLine();
            if (i < numLines - 1) {
                clear += this.cursorUp();
            }
        }
        return clear;
    }
    ;
    bold(str) {
        return `${ESC}${FONT_BOLD}${str}${ESC}${FONT_END_BOLD}`;
    }
    underlined(str) {
        return `${ESC}${FONT_UNDERLINED}${str}${ESC}${FONT_END_UNDERLINED}`;
    }
    italic(str) {
        return `${ESC}${FONT_ITALIC}${str}${ESC}${FONT_END_ITALIC}`;
    }
    light(str) {
        return `${ESC}${FONT_LIGHT}${str}${ESC}${FONT_END_LIGHT}`;
    }
    blink(str) {
        return `${ESC}${FONT_BLINK}${str}${ESC}${FONT_END_BLINK}`;
    }
    inverse(str) {
        return `${ESC}${FONT_INVERSE}${str}${ESC}${FONT_END_INVERSE}`;
    }
    border(str) {
        return `${ESC}${FONT_BORDER}${str}${ESC}${FONT_END_BORDER}`;
    }
    roundedBorder(str) {
        return `${ESC}${FONT_ROUNDED_BORDER}${str}${ESC}${FONT_END_BORDER}`;
    }
    strikethrough(str) {
        return `${ESC}${FONT_STRIKETHROUGH}${str}${ESC}${FONT_END_STRIKETHROUGH}`;
    }
    hidden(str) {
        return `${ESC}${FONT_HIDDEN}${str}${ESC}${FONT_END_HIDDEN}`;
    }
    center(str, targetLength, padChar = ' ') {
        const regex = new RegExp(`${ESC}[^m]+m`, 'g');
        const len = str.replace(regex, '').length;
        const padLeft = Math.max(0, Math.floor((targetLength - len) / 2));
        const padRight = Math.max(0, Math.ceil((targetLength - len) / 2));
        return `${padChar.repeat(padLeft)}${str}${padChar.repeat(padRight)}`;
    }
    left(str, targetLength, padChar = ' ') {
        const regex = new RegExp(`${ESC}[^m]+m`, 'g');
        const len = str.replace(regex, '').length;
        const padding = Math.max(targetLength - len, 1);
        return `${str}${padChar.repeat(padding)}`;
    }
    right(str, targetLength, padChar = ' ') {
        const regex = new RegExp(`${ESC}[^m]+m`, 'g');
        const len = str.replace(regex, '').length;
        const padding = targetLength - len;
        return `${padChar.repeat(padding)}${str}`;
    }
    bgBlue(str) {
        return this._bg(BG_BLUE, str);
    }
    bgBlack(str) {
        return this._bg(BG_BLACK, str);
    }
    bgCyan(str) {
        return this._bg(BG_CYAN, str);
    }
    bgGreen(str) {
        return this._bg(BG_GREEN, str);
    }
    bgMagenta(str) {
        return this._bg(BG_MAGENTA, str);
    }
    bgRed(str) {
        return this._bg(BG_RED, str);
    }
    bgWhite(str) {
        return this._bg(BG_WHITE, str);
    }
    bgYellow(str) {
        return this._bg(BG_YELLOW, str);
    }
    bgRgb(str, r, g, b) {
        return `${ESC}${BG_RGB}${r};${g};${b}m${str}${ESC}${BG_DEFAULT}`;
    }
    bgCustom(str, colorNumber) {
        return `${ESC}${BG_CUSTOM}${colorNumber}m${str}${ESC}${BG_DEFAULT}`;
    }
    fgBlue(str) {
        return this._fg(FG_BLUE, str);
    }
    fgBlack(str) {
        return this._fg(FG_BLACK, str);
    }
    fgCyan(str) {
        return this._fg(FG_CYAN, str);
    }
    fgGreen(str) {
        return this._fg(FG_GREEN, str);
    }
    fgMagenta(str) {
        return this._fg(FG_MAGENTA, str);
    }
    fgRed(str) {
        return this._fg(FG_RED, str);
    }
    fgWhite(str) {
        return this._fg(FG_WHITE, str);
    }
    fgYellow(str) {
        return this._fg(FG_YELLOW, str);
    }
    fgRgb(str, r, g, b) {
        return `${ESC}${FG_RGB}${r};${g};${b}m${str}${ESC}${FG_DEFAULT}`;
    }
    fgCustom(str, colorNumber) {
        return `${ESC}${FG_CUSTOM}${colorNumber}m${str}${ESC}${FG_DEFAULT}`;
    }
    _bg(color, str) {
        return `${ESC}${color}${str}${ESC}${BG_DEFAULT}`;
    }
    _fg(color, str) {
        return `${ESC}${color}${str}${ESC}${FG_DEFAULT}`;
    }
}
exports.CliAnsi = CliAnsi;
//# sourceMappingURL=cli-ansi.js.map