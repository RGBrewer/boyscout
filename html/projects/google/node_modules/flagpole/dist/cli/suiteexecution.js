"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const flagpoleexecutionoptions_1 = require("../flagpoleexecutionoptions");
const flagpolereport_1 = require("../logging/flagpolereport");
const util_1 = require("../util");
const flagpole_1 = require("../flagpole");
const child_process_1 = require("child_process");
var SuiteExecutionExitCode;
(function (SuiteExecutionExitCode) {
    SuiteExecutionExitCode[SuiteExecutionExitCode["success"] = 0] = "success";
    SuiteExecutionExitCode[SuiteExecutionExitCode["failure"] = 1] = "failure";
})(SuiteExecutionExitCode = exports.SuiteExecutionExitCode || (exports.SuiteExecutionExitCode = {}));
class SuiteExecutionResult {
    constructor(output, exitCode) {
        this._output = output;
        this._exitCode = exitCode;
    }
    get output() {
        return this._output;
    }
    get exitCode() {
        return this._exitCode;
    }
    toString() {
        return this._output.join("\n");
    }
}
exports.SuiteExecutionResult = SuiteExecutionResult;
class SuiteExecution {
    constructor() {
        this._result = null;
        this._started = null;
        this._finished = null;
        this._subscribers = [];
        this._finally = [];
        this._output = [];
        this._finishedResolver = () => { };
        this._finishedPromise = new Promise((resolve) => {
            this._finishedResolver = resolve;
        });
    }
    get result() {
        return this._finishedPromise;
    }
    get exitCode() {
        return this._result === null ? null : this._result.exitCode;
    }
    get output() {
        return this._output;
    }
    static executePath(filePath, opts) {
        const execution = new SuiteExecution();
        execution.executePath(filePath, opts);
        return execution;
    }
    static executeSuite(config) {
        const execution = new SuiteExecution();
        execution.executeSuite(config);
        return execution;
    }
    subscribe(callback) {
        this._subscribers.push(callback);
    }
    finally(callback) {
        this._finally.push(callback);
    }
    toString() {
        return this._output.join("\n");
    }
    executePath(filePath, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._result !== null || this._started !== null) {
                throw new Error(`This execution has already run.`);
            }
            this._started = Date.now();
            this._result = yield this._execute(filePath, opts);
            this._finished = Date.now();
            this._finally.forEach((callback) => {
                callback.apply(this, [this]);
            });
            this._finishedResolver(this._result);
            return this._result;
        });
    }
    executeSuite(config) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.executePath(config.getTestPath(), flagpoleexecutionoptions_1.FlagpoleExecution.opts);
        });
    }
    _execute(filePath, opts) {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            opts.exitOnDone = true;
            opts.isChildProcess = true;
            this._executeWithSpawn(filePath, opts, resolve);
        }));
    }
    _executeWithExec(filePath, opts, resolve) {
        const command = `node ${filePath} ${opts.toString()}`;
        child_process_1.exec(command, (err, stdout, stderr) => {
            const exitCode = err && err.code ? err.code : 0;
            if (err) {
                this._logLine("FAILED TEST SUITE:");
                this._logLine(filePath + " exited with error code " + exitCode);
                this._logLine("\n");
                if (stderr) {
                    this._logLine(stderr);
                }
            }
            else {
                this._logLine(stdout);
            }
            resolve(new SuiteExecutionResult(this._output, exitCode));
        });
    }
    _executeWithSpawn(filePath, opts, resolve) {
        const command = [filePath].concat(opts.toArgs());
        const proc = child_process_1.spawn("node", command);
        proc.stdout.on("data", (data) => {
            this._logLine(data);
        });
        proc.stderr.on("data", (data) => {
            this._logLine(data);
        });
        proc.on("error", (err) => {
            this._logLine(err.message);
        });
        proc.on("close", (exitCode) => {
            if (exitCode > 0 && opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.console) {
                this._logLine("FAILED TEST SUITE:");
                this._logLine(filePath + " exited with error code " + exitCode);
                this._logLine("\n");
            }
            resolve(new SuiteExecutionResult(this._output, exitCode));
        });
    }
    _executeWithFork(filePath, opts, resolve) {
        const options = {
            stdio: ["pipe", "pipe", "pipe", "ipc"],
        };
        const proc = child_process_1.fork(filePath, opts.toArgs(), options);
        proc.on("exit", (exitCode) => {
            if ((exitCode == null || exitCode !== 0) &&
                opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.console) {
                this._logLine("FAILED TEST SUITE:");
                this._logLine(filePath + " exited with error code " + exitCode);
                this._logLine("\n");
            }
            resolve(new SuiteExecutionResult(this._output, exitCode === null ? -1 : exitCode));
        });
        proc.on("message", (msg) => {
            console.log("child message received!");
            this._logLine(msg);
        });
    }
    _logLine(data) {
        if (data) {
            const lines = String(data).trim().split("\n");
            lines.forEach((line) => {
                this._output.push(line);
                this._subscribers.forEach((callback) => {
                    callback.apply(this, [line, this]);
                });
            });
        }
    }
}
exports.SuiteExecution = SuiteExecution;
class SuiteExecutionInline extends SuiteExecution {
    static executePath(filePath, opts) {
        const execution = new SuiteExecutionInline();
        execution.executePath(filePath, opts);
        return execution;
    }
    static executeSuite(config) {
        const execution = new SuiteExecutionInline();
        execution.executeSuite(config);
        return execution;
    }
    _execute(filePath, opts) {
        return __awaiter(this, void 0, void 0, function* () {
            let exitCode = SuiteExecutionExitCode.success;
            opts = Object.assign({}, opts);
            opts.automaticallyPrintToConsole = false;
            const globalOpts = Object.assign({}, flagpoleexecutionoptions_1.FlagpoleExecution.opts);
            flagpoleexecutionoptions_1.FlagpoleExecution.opts = opts;
            const preSuiteCount = flagpole_1.Flagpole.suites.length;
            yield require(`${filePath}`);
            const postSuiteCount = flagpole_1.Flagpole.suites.length;
            if (postSuiteCount > preSuiteCount) {
                const createdSuites = flagpole_1.Flagpole.suites.slice(preSuiteCount);
                let promises = [];
                createdSuites.forEach((suite) => {
                    promises.push(suite.finished);
                });
                yield Promise.all(promises);
                yield util_1.asyncForEach(createdSuites, (suite) => __awaiter(this, void 0, void 0, function* () {
                    if (suite.hasFailed) {
                        exitCode = SuiteExecutionExitCode.failure;
                    }
                    const report = new flagpolereport_1.FlagpoleReport(suite, opts);
                    this._logLine(yield report.toString());
                }));
            }
            flagpoleexecutionoptions_1.FlagpoleExecution.opts = globalOpts;
            return new SuiteExecutionResult(this._output, exitCode);
        });
    }
}
exports.SuiteExecutionInline = SuiteExecutionInline;
//# sourceMappingURL=suiteexecution.js.map