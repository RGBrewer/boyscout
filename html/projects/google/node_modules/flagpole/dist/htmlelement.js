"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const domelement_1 = require("./domelement");
const util_1 = require("./util");
const cheerio = require("cheerio");
let $;
class HTMLElement extends domelement_1.DOMElement {
    constructor(input, context, name, path) {
        super(input, context, name || "HTML Element");
        this._path = path || "";
        this._input = input;
        $ = context.response.getRoot();
    }
    get $() {
        return this._input;
    }
    get el() {
        return $(this._input);
    }
    static create(input, context, name = null, path) {
        return __awaiter(this, void 0, void 0, function* () {
            const element = new HTMLElement(input, context, name, path);
            element._tagName = yield element._getTagName();
            element._sourceCode = (yield element.getOuterHtml()).toString();
            if (name === null) {
                if (element._tagName !== null) {
                    element._name = `<${element.tagName}> Element @ ${path}`;
                }
                else if (path) {
                    element._name = String(path);
                }
            }
            return element;
        });
    }
    find(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            const element = this.el.find(selector).eq(0);
            const name = `${selector} under ${this.name}`;
            const path = `${this.path} ${selector}`;
            if (element !== null) {
                return HTMLElement.create(element, this._context, name, path);
            }
            return this._wrapAsValue(null, name);
        });
    }
    findAll(selector) {
        return __awaiter(this, void 0, void 0, function* () {
            const elements = this.el.find(selector).toArray();
            const out = [];
            yield util_1.asyncForEach(elements, (element, i) => __awaiter(this, void 0, void 0, function* () {
                return out.push(yield HTMLElement.create(element, this._context, `${selector}[${i}] under ${this.name}`, `${this.path} ${selector}[${i}]`));
            }));
            return out;
        });
    }
    getClosest(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const closest = yield this.el.closest(selector);
            const name = `Closest ${selector} of ${this.name}`;
            const path = `${this.path}[ancestor-or-self::${selector}]`;
            if (closest.length > 0) {
                return HTMLElement.create(closest[0], this._context, name, path);
            }
            return this._wrapAsValue(null, name, this);
        });
    }
    getChildren(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const children = yield this.el.children(selector);
            const out = [];
            for (let i = 0; i < children.length; i++) {
                out.push(yield HTMLElement.create(children[i], this._context, `Child ${selector} ${i} of ${this.name}`, `${this.path}[child::${selector}][${i}]`));
            }
            return out;
        });
    }
    getSiblings(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const children = yield this.el.siblings(selector);
            const out = [];
            for (let i = 0; i < children.length; i++) {
                out.push(yield HTMLElement.create(children[i], this._context, `Sibling ${selector} ${i} of ${this.name}`, `${this.path}[sibling::${selector}][${i}]`));
            }
            return out;
        });
    }
    getParent() {
        return __awaiter(this, void 0, void 0, function* () {
            const parent = this.el.parent();
            const name = `Parent of ${this.name}`;
            const path = `${this.path}[..]`;
            if (parent !== null) {
                return HTMLElement.create(parent, this._context, name, path);
            }
            return this._wrapAsValue(null, name, this);
        });
    }
    getPreviousSibling(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const siblings = yield this.el.prev(selector);
            const name = `Previous Sibling of ${this.name}`;
            const path = `${this.path}[preceding-sibling::${selector}][0]`;
            if (siblings.length > 0) {
                return HTMLElement.create(siblings[0], this._context, name, path);
            }
            return this._wrapAsValue(null, name, this);
        });
    }
    getPreviousSiblings(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const siblingElements = yield this.el.prevAll(selector);
            const siblings = [];
            for (let i = 0; i < siblingElements.length; i++) {
                siblings.push(yield HTMLElement.create(siblingElements[i], this._context, `Previous Sibling ${i} of ${this.name}`, `${this.path}[preceding-sibling::${selector}][${i}]`));
            }
            return siblings;
        });
    }
    getNextSibling(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const siblings = yield this.el.next(selector);
            const name = `Next Sibling of ${this.name}`;
            const path = `${this.path}[following-sibling::${selector}][0]`;
            if (siblings.length > 0) {
                return HTMLElement.create(siblings[0], this._context, name, path);
            }
            return this._wrapAsValue(null, name, this);
        });
    }
    getNextSiblings(selector = "*") {
        return __awaiter(this, void 0, void 0, function* () {
            const siblingElements = yield this.el.nextAll(selector);
            const siblings = [];
            for (let i = 0; i < siblingElements.length; i++) {
                siblings.push(yield HTMLElement.create(siblingElements[i], this._context, `Next Sibling ${i} of ${this.name}`, `${this.path}[following-sibling::${selector}][${i}]`));
            }
            return siblings;
        });
    }
    click(a, b) {
        return __awaiter(this, void 0, void 0, function* () {
            const overloaded = util_1.getMessageAndCallbackFromOverloading(a, b, this._path);
            if (yield this._isLinkTag()) {
                if (a || b) {
                    this._completedAction("CLICK");
                    return this._loadSubScenario(overloaded);
                }
                else {
                    throw new Error("Calling the element.click() method with no arguements is not yet supported for HTML/DOM type request.");
                }
            }
            else if (yield this._isButtonTag()) {
                const type = yield this.getAttribute("type");
                if (type.isNull() || type.toString().toLowerCase() == "submit") {
                    const form = this._input.closest("form");
                    const formEl = yield HTMLElement.create(form, this._context, `Parent form of ${this.name}`, this.path);
                    this._completedAction("CLICK");
                    return overloaded.scenario === undefined
                        ? formEl.submit(overloaded.message, overloaded.callback)
                        : formEl.submit(overloaded.scenario);
                }
            }
            throw new Error(`${this.name} is not a clickable element.`);
        });
    }
    fillForm(formData) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this._isFormTag())) {
                throw new Error("This is not a form element.");
            }
            const form = this.el;
            for (let name in formData) {
                const value = formData[name];
                form.find(`[name="${name}"]`).val(value);
            }
            this._completedAction("FILL");
        });
    }
    submit(a, b) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._isFormTag()) {
                throw new Error("You can only use .submit() with a form element.");
            }
            if (a || b) {
                const link = yield this._getLink();
                const overloaded = util_1.getMessageAndCallbackFromOverloading(a, b, this._path);
                const scenarioType = yield this._getLambdaScenarioType();
                const opts = yield this._getLambdaScenarioOpts(scenarioType);
                const scenario = this._createSubScenario(overloaded, scenarioType, opts);
                const method = ((yield this._getAttribute("method")) || "get")
                    .toString()
                    .toLowerCase();
                if (link.isNavigation()) {
                    if (method == "get") {
                        link.setQueryString(this.el.serializeArray());
                    }
                    else {
                        const formDataArray = this.el.serializeArray();
                        const formData = {};
                        formDataArray.forEach(function (input) {
                            formData[input.name] = input.value;
                        });
                        scenario.setFormData(formData);
                    }
                    scenario.setMethod(method);
                    scenario.next(overloaded.callback);
                    scenario.open(link.getUri());
                    this._completedAction("SUBMIT");
                }
                else {
                    scenario.skip("Nothing to submit");
                }
                return scenario;
            }
        });
    }
    _getTagName() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.el.get(0).tagName.toLowerCase();
        });
    }
    _getAttribute(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return typeof this.el.get(0).attribs[key] !== "undefined"
                ? this.el.get(0).attribs[key]
                : null;
        });
    }
}
exports.HTMLElement = HTMLElement;
//# sourceMappingURL=htmlelement.js.map