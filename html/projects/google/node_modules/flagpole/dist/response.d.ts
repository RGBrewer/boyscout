/// <reference types="node" />
import { iValue, iResponse, iScenario, iAssertionContext } from "./interfaces";
import { ResponseType } from "./enums";
import { HttpResponse } from "./httpresponse";
export declare function isPuppeteer(type: ResponseType): boolean;
export declare abstract class ProtoResponse implements iResponse {
    readonly scenario: iScenario;
    private _httpResponse;
    abstract get responseType(): ResponseType;
    abstract get responseTypeName(): string;
    abstract find(path: string): Promise<iValue>;
    abstract findAll(path: string): Promise<iValue[]>;
    abstract evaluate(context: any, callback: Function): Promise<any>;
    get isBrowser(): boolean;
    get httpResponse(): HttpResponse;
    get statusCode(): iValue;
    get statusMessage(): iValue;
    get body(): iValue;
    get length(): iValue;
    get headers(): iValue;
    get cookies(): iValue;
    get jsonBody(): iValue;
    get url(): iValue;
    get finalUrl(): iValue;
    get redirectCount(): iValue;
    get loadTime(): iValue;
    get context(): iAssertionContext;
    constructor(scenario: iScenario);
    init(httpResponse: HttpResponse): void;
    absolutizeUri(uri: string): string;
    getRoot(): any;
    header(key: string): iValue;
    cookie(key: string): iValue;
    waitForNavigation(timeout?: number, waitFor?: string | string[]): Promise<void>;
    waitForLoad(timeout?: number): Promise<void>;
    waitForReady(timeout?: number): Promise<void>;
    waitForNetworkIdle(timeout?: number): Promise<void>;
    waitForHidden(selector: string, timeout?: number): Promise<iValue>;
    waitForVisible(selector: string, timeout?: number): Promise<iValue>;
    waitForExists(selector: string, timeout?: number): Promise<iValue>;
    waitForHavingText(selector: string, text: string, timeout?: number): Promise<iValue>;
    screenshot(): Promise<Buffer>;
    type(selector: string, textToType: string, opts?: any): Promise<any>;
    clear(selector: string): Promise<any>;
    waitForXPath(xPath: string): Promise<iValue>;
    findXPath(xPath: string): Promise<iValue>;
    findAllXPath(xPath: string): Promise<iValue[]>;
    findHavingText(selector: string, searchForText: string | RegExp): Promise<iValue>;
    findAllHavingText(selector: string, searchForText: string | RegExp): Promise<iValue[]>;
    selectOption(selector: string, value: string | string[]): Promise<string[]>;
    protected _wrapAsValue(data: any, name: string, source?: any): iValue;
}
