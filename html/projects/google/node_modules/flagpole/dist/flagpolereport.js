"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const consoleline_1 = require("./consoleline");
const _1 = require(".");
const flagpoleexecutionoptions_1 = require("./flagpoleexecutionoptions");
class FlagpoleReport {
    constructor(suite) {
        this.suite = suite;
    }
    getLines() {
        return __awaiter(this, void 0, void 0, function* () {
            let lines = [];
            lines.push(new consoleline_1.HorizontalRule('='));
            lines.push(new consoleline_1.HeadingLine(this.suite.title));
            lines.push(new consoleline_1.HorizontalRule('='));
            lines.push(new consoleline_1.CommentLine('Base URL: ' + this.suite.baseUrl));
            lines.push(new consoleline_1.CommentLine('Environment: ' + _1.Flagpole.executionOpts.environment));
            lines.push(new consoleline_1.CommentLine('Took ' + this.suite.executionDuration + 'ms'));
            let color = this.suite.hasPassed ? consoleline_1.ConsoleColor.FgGreen : consoleline_1.ConsoleColor.FgRed;
            lines.push(new consoleline_1.CustomLine(' Â»   Passed? ' + (this.suite.hasPassed ? 'Yes' : 'No'), color));
            lines.push(new consoleline_1.LineBreak());
            yield this.suite.scenarios.forEach(function (scenario) {
                return __awaiter(this, void 0, void 0, function* () {
                    const log = yield scenario.getLog();
                    log.forEach(function (line) {
                        lines.push(line);
                    });
                    lines.push(new consoleline_1.LineBreak());
                });
            });
            return lines;
        });
    }
    toConsoleString() {
        return __awaiter(this, void 0, void 0, function* () {
            const lines = yield this.getLines();
            let text = '';
            lines.forEach(function (line) {
                text += line.toConsoleString() + "\n";
            });
            return text;
        });
    }
    toRawString() {
        return __awaiter(this, void 0, void 0, function* () {
            const lines = yield this.getLines();
            let text = '';
            lines.forEach(function (line) {
                text += line.toString() + "\n";
            });
            return text;
        });
    }
    toJson() {
        return __awaiter(this, void 0, void 0, function* () {
            const scenarios = this.suite.scenarios;
            let out = {
                title: this.suite.title,
                baseUrl: this.suite.baseUrl,
                summary: {},
                scenarios: []
            };
            let failCount = 0;
            let passCount = 0;
            for (let i = 0; i < scenarios.length; i++) {
                let scenario = scenarios[i];
                const log = yield scenario.getLog();
                out.scenarios[i] = {
                    title: scenario.title,
                    done: scenario.hasFinished,
                    failCount: 0,
                    passCount: 0,
                    log: []
                };
                log.forEach(function (line) {
                    out.scenarios[i].log.push(line.toJson());
                    if (line.type == consoleline_1.LogLineType.Pass) {
                        out.scenarios[i].passCount++;
                        passCount++;
                    }
                    else if (line.type == consoleline_1.LogLineType.Fail) {
                        out.scenarios[i].failCount++;
                        failCount++;
                    }
                });
            }
            out.summary = {
                passed: (failCount == 0),
                passCount: passCount,
                failCount: failCount,
                duration: this.suite.executionDuration
            };
            return out;
        });
    }
    toHTML() {
        return __awaiter(this, void 0, void 0, function* () {
            const scenarios = this.suite.scenarios;
            let html = '';
            html += '<article class="suite">' + "\n";
            html += new consoleline_1.HeadingLine(this.suite.title).toHTML() + "\n";
            html += "<aside>\n";
            html += "<ul>\n";
            html += new consoleline_1.CommentLine('Duration: ' + this.suite.executionDuration + 'ms').toHTML();
            html += new consoleline_1.CommentLine('Base URL: ' + this.suite.baseUrl).toHTML();
            html += new consoleline_1.CommentLine('Environment: ' + _1.Flagpole.executionOpts.environment).toHTML();
            html += "</ul>\n";
            html += "</aside>\n";
            for (let i = 0; i < scenarios.length; i++) {
                let scenario = scenarios[i];
                const log = yield scenario.getLog();
                html += '<section class="scenario">' + "\n";
                html += new consoleline_1.SubheadingLine(scenario.title).toHTML() + "\n";
                html += "<ul>\n";
                log.forEach(function (line) {
                    if (line.type == consoleline_1.LogLineType.Pass ||
                        line.type == consoleline_1.LogLineType.Fail ||
                        line.type == consoleline_1.LogLineType.Comment) {
                        html += line.toHTML();
                    }
                });
                html += "</ul>\n";
                html += "</section>\n";
            }
            html += "</article>\n";
            return html;
        });
    }
    print() {
        return __awaiter(this, void 0, void 0, function* () {
            const lines = yield this.getLines();
            if (_1.Flagpole.executionOpts.logMode) {
                lines.forEach(function (line) {
                    if (line.type != consoleline_1.LogLineType.Decoration) {
                        line.print();
                    }
                });
            }
            else {
                if (_1.Flagpole.executionOpts.output == flagpoleexecutionoptions_1.FlagpoleOutput.html ||
                    _1.Flagpole.executionOpts.output == flagpoleexecutionoptions_1.FlagpoleOutput.browser) {
                    console.log(yield this.toHTML());
                }
                else if (_1.Flagpole.executionOpts.output == flagpoleexecutionoptions_1.FlagpoleOutput.json) {
                    console.log(JSON.stringify(yield this.toJson(), null, 2));
                }
                else {
                    lines.forEach(function (line) {
                        line.print();
                    });
                }
            }
            return this;
        });
    }
}
exports.FlagpoleReport = FlagpoleReport;
//# sourceMappingURL=flagpolereport.js.map