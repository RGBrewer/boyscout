/// <reference types="node" />
import { BrowserControl } from "./browsercontrol";
import { Page } from "puppeteer-core";
import { Assertion } from "./assertion";
import { iResponse, iValue, iAssertionContext, iScenario, iSuite, iAssertionResult, ScreenshotOpts } from "./interfaces";
import { FlagpoleExecutionOptions } from "./flagpoleexecutionoptions";
export declare class AssertionContext implements iAssertionContext {
    protected _scenario: iScenario;
    protected _response: iResponse;
    protected _assertions: Assertion[];
    protected _subScenarios: Promise<any>[];
    result: any;
    get response(): iResponse;
    get scenario(): iScenario;
    get suite(): iSuite;
    get browserControl(): BrowserControl | null;
    get executionOptions(): FlagpoleExecutionOptions;
    get page(): Page | null;
    get incompleteAssertions(): Assertion[];
    get assertionsResolved(): Promise<(iAssertionResult | null)[]>;
    get subScenariosResolved(): Promise<any[]>;
    constructor(scenario: iScenario, response: iResponse);
    comment(message: string): iAssertionContext;
    comment(value: iValue): iAssertionContext;
    assert(message: string, value: any): Assertion;
    assert(value: any): Assertion;
    pause(milliseconds: number): Promise<any>;
    findHavingText(selector: string, searchForText: string | RegExp): Promise<iValue>;
    findAllHavingText(selector: string, searchForText: string | RegExp): Promise<iValue[]>;
    clearThenType(selector: string, textToType: string, opts?: any): Promise<any>;
    clear(selector: string): Promise<void>;
    type(selector: string, textToType: string, opts?: any): Promise<void>;
    select(selector: string, value: string | string[]): Promise<void>;
    evaluate(callback: Function): Promise<any>;
    waitForReady(timeout?: number): Promise<void>;
    waitForLoad(timeout?: number): Promise<void>;
    waitForNetworkIdle(timeout?: number): Promise<void>;
    waitForNavigation(timeout?: number, waitFor?: string | string[]): Promise<void>;
    waitForHavingText(selector: string, text: string, timeout?: number): Promise<iValue>;
    waitForXPath(xPath: string, timeout?: number): Promise<iValue>;
    waitForHidden(selector: string, timeout?: number): Promise<iValue>;
    waitForVisible(selector: string, timeout?: number): Promise<iValue>;
    waitForExists(selector: string, timeout?: number): Promise<iValue>;
    exists(selector: string): Promise<iValue>;
    exists(message: string, selector: string): Promise<iValue>;
    find(selector: string): Promise<iValue>;
    findAll(selector: string): Promise<iValue[]>;
    findXPath(xPath: string): Promise<iValue>;
    findAllXPath(xPath: string): Promise<iValue[]>;
    submit(selector: string): Promise<any>;
    click(selector: string): Promise<void>;
    click(selector: string, scenario: iScenario): Promise<iScenario>;
    click(selector: string, message: string): Promise<iScenario>;
    click(selector: string, callback: Function): Promise<iScenario>;
    openInBrowser(): Promise<string>;
    screenshot(): Promise<Buffer>;
    screenshot(localFilePath: string): Promise<Buffer>;
    screenshot(localFilePath: string, opts: ScreenshotOpts): Promise<Buffer>;
    screenshot(opts: ScreenshotOpts): Promise<Buffer>;
    set(aliasName: string, value: any): iAssertionContext;
    get(aliasName: string): any;
    protected _completedAction(verb: string, noun?: string): Promise<void>;
    protected _failedAction(verb: string, noun?: string): Promise<void>;
}
