"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const consoleline_1 = require("./consoleline");
const flagpoleexecutionoptions_1 = require("../flagpoleexecutionoptions");
const comment_1 = require("./comment");
const enums_1 = require("../enums");
const util_1 = require("../util");
class FlagpoleReport {
    constructor(suite, opts) {
        this.suite = suite;
        this.opts = opts;
    }
    toConsole() {
        return __awaiter(this, void 0, void 0, function* () {
            let lines = [];
            lines.push(new consoleline_1.HeadingLine(this.suite.title));
            lines.push(new consoleline_1.CommentLine(`Base URL: ${this.suite.baseUrl}`));
            lines.push(new consoleline_1.CommentLine(`Environment: ${flagpoleexecutionoptions_1.FlagpoleExecution.opts.environment}`));
            lines.push(new consoleline_1.CommentLine(`Took ${this.suite.executionDuration}ms`));
            const failCount = this.suite.failCount;
            const totalCount = this.suite.scenarios.length;
            failCount == 0
                ? lines.push(new consoleline_1.PassLine(`Passed (${totalCount} scenario${totalCount == 1 ? "" : "s"})`))
                : lines.push(new consoleline_1.FailLine(`Failed (${failCount} of ${totalCount} scenario${totalCount == 1 ? "" : "s"})`));
            lines.push(new consoleline_1.LineBreak());
            yield util_1.asyncForEach(this.suite.scenarios, (scenario) => __awaiter(this, void 0, void 0, function* () {
                const log = yield scenario.getLog();
                log.forEach((item) => {
                    lines = lines.concat(item.toConsole());
                });
                lines.push(new consoleline_1.LineBreak());
            }));
            return lines;
        });
    }
    toJson() {
        return __awaiter(this, void 0, void 0, function* () {
            const scenarios = this.suite.scenarios;
            let out = {
                title: this.suite.title,
                baseUrl: String(this.suite.baseUrl),
                summary: {},
                scenarios: []
            };
            let failCount = 0;
            let passCount = 0;
            for (let i = 0; i < scenarios.length; i++) {
                let scenario = scenarios[i];
                const log = yield scenario.getLog();
                out.scenarios[i] = {
                    title: scenario.title,
                    done: scenario.hasFinished,
                    failCount: 0,
                    passCount: 0,
                    log: []
                };
                log.forEach((item) => {
                    out.scenarios[i].log.push(item.toJson());
                    if (item.type == enums_1.LogItemType.Result) {
                        if (item.passed) {
                            out.scenarios[i].passCount++;
                            passCount++;
                        }
                        else if (item.failed && item.isOptional) {
                            out.scenarios[i].failCount++;
                            failCount++;
                        }
                    }
                });
            }
            out.summary = {
                passed: failCount == 0,
                passCount: passCount,
                failCount: failCount,
                duration: this.suite.executionDuration
            };
            return out;
        });
    }
    toHTML() {
        return __awaiter(this, void 0, void 0, function* () {
            const scenarios = this.suite.scenarios;
            let html = "";
            html += '<article class="suite">' + "\n";
            html += `<h2>${this.suite.title}</h2>\n`;
            html += "<aside>\n";
            html += "<ul>\n";
            html += `
            <li>Duration: ${this.suite.executionDuration}ms</li>
            <li>Base URL: ${this.suite.baseUrl}</li>
            <li>Environment: ${flagpoleexecutionoptions_1.FlagpoleExecution.opts.environment}</li>
        `;
            html += "</ul>\n";
            html += "</aside>\n";
            for (let i = 0; i < scenarios.length; i++) {
                let scenario = scenarios[i];
                const log = yield scenario.getLog();
                html += '<section class="scenario">' + "\n";
                html += `
                <h3>${scenario.title}</h3>
            `;
                html += "<ul>\n";
                log.forEach((item) => {
                    if (item.type == enums_1.LogItemType.Result ||
                        item.type == enums_1.LogItemType.Comment) {
                        html += item.toHtml();
                    }
                });
                html += "</ul>\n";
                html += "</section>\n";
            }
            html += "</article>\n";
            return html;
        });
    }
    toDelimited(format) {
        return __awaiter(this, void 0, void 0, function* () {
            const funcName = `to${format.charAt(0).toUpperCase()}${format.slice(1)}`;
            if (!Reflect.has(new comment_1.LogComment(""), funcName)) {
                throw new Error(`Method for ${funcName} does not exist.`);
            }
            let lines = [];
            yield this.suite.scenarios.forEach(function (scenario) {
                return __awaiter(this, void 0, void 0, function* () {
                    const log = yield scenario.getLog();
                    log.forEach((item) => {
                        lines.push(item[funcName]());
                    });
                });
            });
            return lines;
        });
    }
    print() {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield this.toString();
            const lines = output.split("\n");
            lines.forEach(line => {
                process.send ? process.send(line) : console.log(line);
            });
        });
    }
    toString() {
        return __awaiter(this, void 0, void 0, function* () {
            let out = "";
            if (this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.html ||
                this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.browser) {
                out += yield this.toHTML();
            }
            else if (this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.json) {
                const json = yield this.toJson();
                out += JSON.stringify(json, null, 2);
            }
            else if (this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.console) {
                (yield this.toConsole()).forEach((line) => {
                    out += line.toConsoleString() + "\n";
                });
            }
            else if (this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.text) {
                (yield this.toConsole()).forEach((line) => {
                    out += line.toString() + "\n";
                });
            }
            else if (this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.csv ||
                this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.psv ||
                this.opts.output == flagpoleexecutionoptions_1.FlagpoleOutput.tsv) {
                const format = flagpoleexecutionoptions_1.FlagpoleOutput[this.opts.output];
                (yield this.toDelimited(format)).forEach((line) => {
                    out += line + "\n";
                });
            }
            return out;
        });
    }
}
exports.FlagpoleReport = FlagpoleReport;
//# sourceMappingURL=flagpolereport.js.map