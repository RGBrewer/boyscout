"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const enums_1 = require("../enums");
const consoleline_1 = require("./consoleline");
const logitem_1 = require("./logitem");
const util_1 = require("../util");
class AssertionResult extends logitem_1.LogItem {
    constructor() {
        super(...arguments);
        this.type = enums_1.LogItemType.Result;
        this._sourceCode = null;
        this._highlight = '';
    }
}
exports.AssertionResult = AssertionResult;
class AssertionPass extends AssertionResult {
    constructor(message) {
        super(message);
        this.className = 'pass';
    }
    get passed() {
        return true;
    }
    toConsole() {
        return [new consoleline_1.PassLine(this.message)];
    }
}
exports.AssertionPass = AssertionPass;
class AssertionActionCompleted extends AssertionPass {
    constructor(verb, noun) {
        super(`${verb} ${noun}`);
        this._verb = verb;
        this._noun = noun;
    }
    toConsole() {
        return [new consoleline_1.ActionCompletedLine(this._verb, this._noun)];
    }
}
exports.AssertionActionCompleted = AssertionActionCompleted;
class AssertionFail extends AssertionResult {
    constructor(message, errorDetails, sourceCode = null, highlight = '') {
        super(message);
        this.className = 'fail';
        this._rawDetails = errorDetails;
        this._sourceCode = sourceCode;
        this._highlight = highlight;
    }
    get failed() {
        return true;
    }
    get isDetails() {
        return !!this._rawDetails;
    }
    get sourceCode() {
        return String(this._sourceCode);
    }
    get detailsMessage() {
        if (util_1.isNullOrUndefined(this._rawDetails)) {
            return '';
        }
        const type = util_1.toType(this._rawDetails);
        const details = this._rawDetails;
        if (type == 'array') {
            const arr = details;
            if (arr.every((item) => { return typeof item == 'string'; })) {
                return this._rawDetails;
            }
        }
        else if (details && details.message) {
            return details.message;
        }
        return String(details);
    }
    toConsole() {
        const lines = [new consoleline_1.FailLine(this.message)];
        const details = this.detailsMessage;
        if (details) {
            lines.push(new consoleline_1.DetailLine(this.detailsMessage));
        }
        if (this.sourceCode && this.sourceCode != 'null') {
            lines.push(new consoleline_1.SourceCodeBlock(this.sourceCode, this._highlight));
        }
        return lines;
    }
}
exports.AssertionFail = AssertionFail;
class AssertionFailOptional extends AssertionFail {
    constructor() {
        super(...arguments);
        this.className = 'failOptional';
    }
    get isOptional() {
        return true;
    }
    toConsole() {
        return [new consoleline_1.OptionalFailLine(this.message)];
    }
}
exports.AssertionFailOptional = AssertionFailOptional;
class AssertionFailWarning extends AssertionFail {
    constructor() {
        super(...arguments);
        this.className = 'failWarning';
    }
    get isOptional() {
        return true;
    }
    toConsole() {
        return [new consoleline_1.WarningLine(this.message)];
    }
}
exports.AssertionFailWarning = AssertionFailWarning;
class AssertionActionFailed extends AssertionPass {
    constructor(verb, noun) {
        super(`${verb} ${noun}`);
        this._verb = verb;
        this._noun = noun;
    }
    toConsole() {
        return [new consoleline_1.ActionFailedLine(this._verb, this._noun)];
    }
}
exports.AssertionActionFailed = AssertionActionFailed;
//# sourceMappingURL=assertionresult.js.map