"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http = require("http");
const fs = require("fs");
class WebResponse {
    constructor(response, opts) {
        this._output = "";
        this._response = response;
        if (opts.templatePath) {
            this._output = fs.readFileSync(opts.templatePath, "utf8");
        }
        else if (opts.input) {
            this._output = opts.input;
        }
    }
    static createFromTemplate(response, templatePath) {
        return new WebResponse(response, { templatePath: templatePath });
    }
    static createFromInput(response, input) {
        return new WebResponse(response, { input: input });
    }
    replace(key, value) {
        this._output = this._output.replace("${" + key + "}", value);
        return this;
    }
    parse(replace) {
        for (let key in replace) {
            this.replace(key, replace[key]);
        }
        return this;
    }
    send(replace) {
        if (typeof replace != "undefined") {
            this.parse(replace);
        }
        this._response.end(this._output);
        return this;
    }
}
exports.WebResponse = WebResponse;
class WebServer {
    constructor(requestHandler) {
        this._httpPort = 3000;
        this._server = http.createServer(requestHandler);
    }
    get isListening() {
        return this._server.listening;
    }
    get httpPort() {
        return this._httpPort;
    }
    set httpPort(value) {
        this._httpPort = value;
    }
    listen(port) {
        if (this.isListening) {
            throw new Error("HTTP Server is already listening.");
        }
        return new Promise((resolve, reject) => {
            if (typeof port != "undefined" && port > 0) {
                this._httpPort = Math.ceil(port);
            }
            this._server
                .listen({ port: this._httpPort }, () => {
                resolve();
            })
                .on("error", (err) => {
                if (err) {
                    return reject(`Could not listen on port ${this._httpPort}: ${err}`);
                }
            });
        });
    }
    close() {
        return new Promise(resolve => {
            if (this.isListening) {
                this._server.close(() => {
                    resolve();
                });
            }
            else {
                resolve();
            }
        });
    }
}
exports.WebServer = WebServer;
//# sourceMappingURL=webserver.js.map